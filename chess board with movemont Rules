
//#include <conio.h>
#include <graphics.h>
#include <stdio.h>
#include<process.h>
//#include<iostream>
#include<math.h>
//using namespace std;


char board[6][5] =
{
    {'Q','K', 'B','N','R'},
    {'P', 'P', 'P','P','P'},
    {' ', ' ', ' ',' ',' '},
    {' ', ' ', ' ',' ',' '},
    {'p', 'p', 'p','p','p'},
    {'r', 'n', 'b','k','q'}
};

int whooseMove = 0;

// whooseMove = 0, white's move
// whooseMove = 1, black's move




//function for inserting image
int setpiece(char piece,int x1, int y1, int x2, int y2)
{

    if(piece=='K')
    {

        readimagefile("w_king.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='Q')
    {

        readimagefile("w_queen.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='P')
    {

        readimagefile("w_pawn.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='R')
    {

        readimagefile("w_rook.gif",x1+20,y1+20,x2-20,y2-20);
    }


    if(piece=='N')
    {

        readimagefile("w_knight.gif",x1+20,y1+20,x2-20,y2-20);
    }


    if(piece=='B')
    {

        readimagefile("w_bishop.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='k')
    {

        readimagefile("b_king.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='q')
    {

        readimagefile("b_queen.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='r')
    {

        readimagefile("b_rook.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='n')
    {

        readimagefile("b_knight.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='p')
    {

        readimagefile("b_pawn.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='b')
    {
        //outtextxy(x1+25,y1+50,"Bishop");

        readimagefile("b_bishop.gif",x1+20,y1+20,x2-20,y2-20);
    }




}


int DrawChessboard()
{
    cleardevice();
    int x = 100, y = 100;
    int r, c;

    int  black = 0;
    int size = 100;

    for ( r = 0; r < 6; r++)
    {

        // iterate over 5cols
        for ( c = 0; c < 5; c++)
        {
            // color as black
            if (black == 0)
            {

                // set next color as white
                setcolor(WHITE);

                setfillstyle(SOLID_FILL, DARKGRAY);

                // creating rectangle
                // with length and breadth
                rectangle(x, y, x + size, y + size);

                // Fill an enclosed area
                floodfill(x + 1, y + 1, WHITE);

                // Set black to true
                black = 1;
            }

            // If current block is to
            // color as white
            else
            {
                setcolor(WHITE);


                // for whitw boxes
                setfillstyle(SOLID_FILL, WHITE);

                // creating rectangle
                // with length and breadth
                rectangle(x, y, x + size, y + size);

                // Fill an enclosed area
                floodfill(x + 1, y + 1, WHITE);

                // Set black to false
                black = 0;
            }
            setpiece(board[r][c],x,y,x+size,y+size);
            printf("%d%d %c\n",r,c,board[r][c]);


            x = x + size;


            delay(10);

        }

        delay(10);
        x = size;
        y = size + y;
    }



     settextstyle(6,0,3);             //font,direction,font_size
     outtextxy(660,50,"Whoose");
     outtextxy(670,70,"Turn?");


    if(whooseMove==0){
          settextstyle(6,0,3);          //font,direction,font_size
          outtextxy(660,150, "White");
          outtextxy(660,170, "player");
    }


    else{
          settextstyle(6,0,3);                //font,direction,font_size
          outtextxy(660,550,"Black");
           outtextxy(660,570, "Player");
     }



}




int selectedx= 0, selectedy = 0;

void selectandmove()
{
    delay(1);
    setcolor(RED);

    for (int i = 0; i < 5; ++i)
    {

        rectangle(selectedx*100 - i, selectedy*100 - i, selectedx*100+100 + i, selectedy*100+100 + i);

    }
    //  printf(" selectedx=%d ,selectedy=%d",selectedx,selectedy);
    delay(1);
}




// Function to validate and print valid rook moves
 int rookmove(int x, int y) {
    // Check if the selected piece is a rook
     char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'R' && piece != 'r') {
        //printf("Invalid piece selected.\n");
        return 0;
    }
    printf("Rook moves from %d%d to %d%d",selectedy - 1,selectedx - 1,y-1,x-1);
    // Check if the rook moves horizontally (same y-axis) or vertically (same x-axis)
    if (selectedx == x || selectedy == y) {
        // Check if the path is clear (no other pieces in the way)
        int dx = (x > selectedx) ? 1 : ((x < selectedx) ? -1 : 0);
        int dy = (y > selectedy) ? 1 : ((y < selectedy) ? -1 : 0);

        for (int i = selectedx + dx, j = selectedy + dy; i != x || j != y; i += dx, j += dy) {
            if (board[j - 1][i - 1] != ' ') {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the rook move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 6; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }

    else {
        printf("Invalid rook move.\n");
        return 0;
    }

    return 1;
}



bool pawnmove(int x, int y)
    {
        delay(1);
        //  printf("from: %d,%d %c\n",selectedy-1,selectedx-1, board[selectedy-1][selectedx-1]);
        // printf("to: %d,%d %c\n",y-1,x-1,board[y-1][x-1]);
        if(board[y-1][x-1]!=' ')
            return false;

        else
        {
            if(board[selectedy-1][selectedx-1]=='P')
                if(selectedx==x && selectedy+1==y)
                {
                    board[y-1][x-1] = board[selectedy-1][selectedx-1];
                    board[selectedy-1][selectedx-1] = ' ';

                }

            if(board[selectedy-1][selectedx-1]=='p')
                if(selectedx==x && selectedy-1==y)
                {
                    board[y-1][x-1] = board[selectedy-1][selectedx-1];
                    board[selectedy-1][selectedx-1] = ' ';
                }

        }



        DrawChessboard();
        delay(1);
    }



int bishopmove(int x, int y) {
    // Check if the selected piece is a bishop
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'B' && piece != 'b') {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the bishop moves diagonally (same absolute difference between x and y)
    int dx = x - selectedx;
    int dy = y - selectedy;
    if (fabs(dx) == fabs(dy)) {
        // Check if the path is clear (no other pieces in the way)
        int dirX = (dx > 0) ? 1 : -1;
        int dirY = (dy > 0) ? 1 : -1;

        for (int i = selectedx + dirX, j = selectedy + dirY; i != x || j != y; i += dirX, j += dirY) {
            if (board[j - 1][i - 1] != ' ') {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the bishop move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 6; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    } else {
        printf("Invalid bishop move.\n");
        return 0;
    }
    return 1;
}

int knightmove(int x, int y) {
    // Check if the selected piece is a knight
   char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'N' && piece != 'n') {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the knight moves in an L-shape (two squares in one direction and one square in a perpendicular direction)
    int dx = x - selectedx;
    int dy = y - selectedy;
    if ((dx * dx + dy * dy == 5) && (dx != 0) && (dy != 0)) {
        // Perform the knight move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 6; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    } else {
        printf("Invalid knight move.\n");
        return 0;
    }

    return 1;
}



int queenmove(int x, int y) {
    // Check if the selected piece is a queen
   char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'Q' && piece != 'q') {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the queen moves horizontally, vertically, or diagonally
    int dx = x - selectedx;
    int dy = y - selectedy;
    if (dx == 0 || dy == 0 || fabs(dx) == fabs(dy)) {
        // Check if the path is clear (no other pieces in the way)
        int dirX = (dx > 0) ? 1 : ((dx < 0) ? -1 : 0);
        int dirY = (dy > 0) ? 1 : ((dy < 0) ? -1 : 0);

        for (int i = selectedx + dirX, j = selectedy + dirY; i != x || j != y; i += dirX, j += dirY) {
            if (board[j - 1][i - 1] != ' ') {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the queen move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 6; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    } else {
        printf("Invalid queen move.\n");
        return 0;
    }

    return 1;
}

int kingmove(int x, int y) {
    // Check if the selected piece is a king
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'K' && piece != 'k') {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the king moves one square in any direction
    int dx = x - selectedx;
    int dy = y - selectedy;
    if ((dx >= -1 && dx <= 1) && (dy >= -1 && dy <= 1) && (dx != 0 || dy != 0)) {
        // Perform the king move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 6; j++) {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    } else {
        printf("Invalid king move.\n");
        return 0;
    }
    return 1;
}






    int moving = 0;


    int selectSquare(int x, int y)
    {


        int x1 = x*100, y1 = y*100, x2 = x*100+100, y2 = y*100+100;


        while(1)
        {
            //cleardevice();
            if(moving==1)
            {
                selectandmove();
                delay(1);
            }

            setcolor(LIGHTGREEN);
            //rectangle(100,100,200,200);
            for (int i = 0; i < 5; ++i)
            {

                rectangle(x*100 - i, y*100 - i, x*100+100 + i, y*100+100 + i);

            }


            if(GetAsyncKeyState(VK_RIGHT))
            {
                //x1 += 100;
                //x2 += 100;
                x += 1;
                cleardevice();
                DrawChessboard();
                if(moving==1)
                {
                    selectandmove();
                    delay(1);
                }
            }

            if(GetAsyncKeyState(VK_LEFT))
            {
                //x1 -= 100;
                //x2 -= 100;
                x-=1;
                cleardevice();
                DrawChessboard();
                if(moving==1)
                {
                    selectandmove();
                    delay(1);
                }
            }



            if(GetAsyncKeyState(VK_UP))
            {
                //y1 -= 100;
                //y2 -= 100;
                y-=1;
                cleardevice();
                DrawChessboard();
                if(moving==1)
                {
                    selectandmove();
                    delay(1);
                }
            }

            if(GetAsyncKeyState(VK_DOWN))
            {
                //y1 += 100;
                //y2 += 100;
                y+=1;
                cleardevice();
                DrawChessboard();
                if(moving==1)
                {
                    selectandmove();
                    delay(1);
                }
            }

            if(GetAsyncKeyState(VK_RETURN))
            {
                if(moving==0)
                {
                    selectedx = x;
                    selectedy = y;
                    selectandmove();
                    moving = 1;
                }

                else
                {
                    if(board[selectedy-1][selectedx-1] >= 65 && board[selectedy-1][selectedx-1] <= 90){
                        if(whooseMove == 0){
                            printf("WHITEMOVED,%c",board[selectedy-1][selectedx-1]);



                            pawnmove(x,y);
                            rookmove(x,y);
                            bishopmove(x,y);
                            knightmove(x,y);
                            queenmove(x,y);
                            kingmove(x,y);
                            whooseMove = 1;
                            moving=0;
                            selectedx = 0;
                            selectedy = 0;
                            DrawChessboard();
                        }
                        else{
                            moving=0;
                            selectedx = 0;
                            selectedy = 0;
                          DrawChessboard();
                            if(moving==1)
                            {
                                selectandmove();
                                delay(1);
                            }
                        }
                    }
                    else{
                        if(whooseMove == 1){
                            printf("BLACKMOVED,%c",board[selectedy-1][selectedx-1]);
                            pawnmove(x,y);
                            rookmove(x,y);
                            bishopmove(x,y);
                            knightmove(x,y);
                            queenmove(x,y);
                            kingmove(x,y);
                            whooseMove = 0;
                            moving=0;
                            selectedx = 0;
                            selectedy = 0;
                            DrawChessboard();
                            /*if(moving==1)
                            {
                                selectandmove();
                                delay(1);
                            }*/

                        }
                        else{
                            moving=0;
                            selectedx = 0;
                            selectedy = 0;
                           DrawChessboard();
                            /*if(moving==1)
                            {
                                selectandmove();
                                delay(1);
                            }*/
                        }
                    }

                }

                x++;
                y++;
                delay(30);
            }

            //DrawChessboard();
            delay(30);
        }
        return 0;

    }






    int main()
    {


        int gr = DETECT, gm;

        initwindow(800,800,"MENU",0,0,false,true);

        DrawChessboard();

        selectSquare(1,1);


        getch();
        closegraph();


        return 0;
    }

