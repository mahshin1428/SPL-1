
//#include <conio.h>
#include <graphics.h>
#include <stdio.h>
#include<process.h>
//#include<iostream>
#include<math.h>
//using namespace std;


char board[6][5] =
{
    {'Q','K', 'B','N','R'},
    {'P', 'P', 'P','P','P'},
    {' ', ' ', ' ',' ',' '},
    {' ', ' ', ' ',' ',' '},
    {'p', 'p', 'p','p','p'},
    {'r', 'n', 'b','k','q'}
};


int pawnvalue=1;
int rookvalue=4;
int knightvalue=5;
int bishopvalue=3;
int queenvalue=7;
int kingvalue=9;

int whooseMove = 0;
int selectedx= 0;
int selectedy = 0;


// whooseMove = 0, white's move
// whooseMove = 1, black's move




int setpiece(char piece,int x1, int y1, int x2, int y2)
{

    if(piece=='K')
    {

        readimagefile("w_king.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='Q')
    {

        readimagefile("w_queen.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='P')
    {

        readimagefile("w_pawn.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='R')
    {

        readimagefile("w_rook.gif",x1+20,y1+20,x2-20,y2-20);
    }


    if(piece=='N')
    {

        readimagefile("w_knight.gif",x1+20,y1+20,x2-20,y2-20);
    }


    if(piece=='B')
    {

        readimagefile("w_bishop.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='k')
    {

        readimagefile("b_king.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='q')
    {

        readimagefile("b_queen.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='r')
    {

        readimagefile("b_rook.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='n')
    {

        readimagefile("b_knight.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='p')
    {

        readimagefile("b_pawn.gif",x1+20,y1+20,x2-20,y2-20);
    }

    if(piece=='b')
    {
        //outtextxy(x1+25,y1+50,"Bishop");

        readimagefile("b_bishop.gif",x1+20,y1+20,x2-20,y2-20);
    }




}


int DrawChessboard()
{
    cleardevice();
    int x = 100, y = 100;
    int r, c;

    int  black = 0;
    int size = 100;

    for ( r = 0; r < 6; r++)
    {

        // iterate over 5cols
        for ( c = 0; c < 5; c++)
        {
            // color as black
            if (black == 0)
            {

                // set next color as white
                setcolor(WHITE);

                setfillstyle(SOLID_FILL, DARKGRAY);

                // creating rectangle
                // with length and breadth
                rectangle(x, y, x + size, y + size);

                // Fill an enclosed area
                floodfill(x + 1, y + 1, WHITE);

                // Set black to true
                black = 1;
            }

            // If current block is to
            // color as white
            else
            {
                setcolor(WHITE);


                // for whitw boxes
                setfillstyle(SOLID_FILL, WHITE);

                // creating rectangle
                // with length and breadth
                rectangle(x, y, x + size, y + size);

                // Fill an enclosed area
                floodfill(x + 1, y + 1, WHITE);

                // Set black to false
                black = 0;
            }
            setpiece(board[r][c],x,y,x+size,y+size);
            printf("%d%d %c\n",r,c,board[r][c]);


            x = x + size;


            delay(10);

        }

        delay(10);
        x = size;
        y = size + y;
    }

    settextstyle(6,0,3);
    outtextxy(660,50,"Whoose");
    outtextxy(670,70,"Turn?");



    if(whooseMove==0)
    {

        settextstyle(6,0,3);   //font,direction,font_size
        outtextxy(660,150, "White");
        outtextxy(660,170, "player");
    }

    else
    {
        settextstyle(6,0,3);   //font,direction,font_size
        outtextxy(660,550,"Black");
        outtextxy(660,570, "Player");


    }



}









// Function to validate and print valid rook moves
int rookmove(int x, int y)
{
    // Check if the selected piece is a rook
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'R' && piece != 'r')
    {
        //printf("Invalid piece selected.\n");
        return 0;
    }
    printf("Rook moves from %d%d to %d%d",selectedy - 1,selectedx - 1,y-1,x-1);
    // Check if the rook moves horizontally (same y-axis) or vertically (same x-axis)
    if (selectedx == x || selectedy == y)
    {
        // Check if the path is clear (no other pieces in the way)
        int dx = (x > selectedx) ? 1 : ((x < selectedx) ? -1 : 0);
        int dy = (y > selectedy) ? 1 : ((y < selectedy) ? -1 : 0);

        for (int i = selectedx + dx, j = selectedy + dy; i != x || j != y; i += dx, j += dy)
        {
            if (board[j - 1][i - 1] != ' ')
            {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the rook move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }

    else
    {
        printf("Invalid rook move.\n");
        return 0;
    }

    return 1;
}




bool pawnmove(int x, int y)
{
    delay(1);

    // Check if the destination square is not empty
    if (board[y - 1][x - 1] != ' ')
    {
        char piece = board[selectedy - 1][selectedx - 1];

        // Check if it's a valid capture for the white pawn
        if (piece == 'P' && selectedx != x && selectedy + 1 == y)
        {
            board[y - 1][x - 1] = board[selectedy - 1][selectedx - 1];
            board[selectedy - 1][selectedx - 1] = ' ';
        }
        // Check if it's a valid capture for the black pawn
        else if (piece == 'p' && selectedx != x && selectedy - 1 == y)
        {
            board[y - 1][x - 1] = board[selectedy - 1][selectedx - 1];
            board[selectedy - 1][selectedx - 1] = ' ';
        }
        else
        {
            // Invalid capture, return false
            return false;
        }
    }
    else
    {
        // The destination square is empty, perform regular move
        char piece = board[selectedy - 1][selectedx - 1];

        if (piece == 'P' && selectedx == x && selectedy + 1 == y)
        {
            board[y - 1][x - 1] = board[selectedy - 1][selectedx - 1];
            board[selectedy - 1][selectedx - 1] = ' ';
        }
        else if (piece == 'p' && selectedx == x && selectedy - 1 == y)
        {
            board[y - 1][x - 1] = board[selectedy - 1][selectedx - 1];
            board[selectedy - 1][selectedx - 1] = ' ';
        }
        else
        {
            // Invalid move, return false
            return false;
        }
    }

    DrawChessboard();
    delay(1);

    return true;
}



int bishopmove(int x, int y)
{

    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'B' && piece != 'b')
    {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the bishop moves diagonally (same absolute difference between x and y)
    int dx = x - selectedx;
    int dy = y - selectedy;
    if (fabs(dx) == fabs(dy))
    {
        // Check if the path is clear (no other pieces in the way)
        int dirX = (dx > 0) ? 1 : -1;
        int dirY = (dy > 0) ? 1 : -1;

        for (int i = selectedx + dirX, j = selectedy + dirY; i != x || j != y; i += dirX, j += dirY)
        {
            if (board[j - 1][i - 1] != ' ')
            {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the bishop move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }
    else
    {
        printf("Invalid bishop move.\n");
        return 0;
    }
    return 1;
}

int knightmove(int x, int y)
{
    // Check if the selected piece is a knight
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'N' && piece != 'n')
    {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the knight moves in an L-shape (two squares in one direction and one square in a perpendicular direction)
    int dx = x - selectedx;
    int dy = y - selectedy;
    if ((dx * dx + dy * dy == 5) && (dx != 0) && (dy != 0))
    {
        // Perform the knight move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }
    else
    {
        printf("Invalid knight move.\n");
        return 0;
    }

    return 1;
}



int queenmove(int x, int y)
{
    // Check if the selected piece is a queen
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'Q' && piece != 'q')
    {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the queen moves horizontally, vertically, or diagonally
    int dx = x - selectedx;
    int dy = y - selectedy;
    if (dx == 0 || dy == 0 || fabs(dx) == fabs(dy))
    {
        // Check if the path is clear (no other pieces in the way)
        int dirX = (dx > 0) ? 1 : ((dx < 0) ? -1 : 0);
        int dirY = (dy > 0) ? 1 : ((dy < 0) ? -1 : 0);

        for (int i = selectedx + dirX, j = selectedy + dirY; i != x || j != y; i += dirX, j += dirY)
        {
            if (board[j - 1][i - 1] != ' ')
            {
                printf("Path is blocked.\n");
                return 0;
            }
        }

        // Perform the queen move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }
    else
    {
        printf("Invalid queen move.\n");
        return 0;
    }

    return 1;
}

int kingmove(int x, int y)
{
    // Check if the selected piece is a king
    char piece = board[selectedy - 1][selectedx - 1];
    if (piece != 'K' && piece != 'k')
    {
        printf("Invalid piece selected.\n");
        return 0;
    }

    // Check if the king moves one square in any direction
    int dx = x - selectedx;
    int dy = y - selectedy;
    if ((dx >= -1 && dx <= 1) && (dy >= -1 && dy <= 1) && (dx != 0 || dy != 0))
    {
        // Perform the king move
        board[y - 1][x - 1] = piece;
        board[selectedy - 1][selectedx - 1] = ' ';

        // Print the updated chessboard
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                printf("%c ", board[i][j]);
            }
            printf("\n");
        }
    }
    else
    {
        printf("Invalid king move.\n");
        return 0;
    }
    return 1;
}


//pawn attack

void pawnCheck(int x, int y, int whooseMove)
{
    int dy = (whooseMove == 0) ? 1 : -1; // Direction of pawn movement based on whose move it is

    // Check for possible pawn attacks
    if (x - 1 >= 0 && board[x - 1][y] == 'p')
    {
        // Pawn is attacking from the left
        return; // King is under check by the pawn
    }

    if (x + 1 < 6 && board[x + 1][y] == 'p')
    {
        // Pawn is attacking from the right
        return; // King is under check by the pawn
    }

    // Check for possible en passant captures
    if (y - 1 >= 0 && board[x + dy][y - 1] == 'p')
    {
        // Pawn is attacking from the left (en passant)
        return; // King is under check by the pawn
    }

    if (y + 1 < 5 && board[x + dy][y + 1] == 'p')
    {
        // Pawn is attacking from the right (en passant)
        return; // King is under check by the pawn
    }

    return;
}


//knight attack

void knightCheck(int x, int y, int whooseMove)
{
    int dx[8] = {2, 1, -1, -2, -2, -1, 1, 2};
    int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

    for (int i = 0; i < 8; ++i)
    {
        int row = x + dx[i];
        int col = y + dy[i];

        if (row >= 0 && row < 6 && col >= 0 && col < 5)
        {
            if ((whooseMove == 0 && board[row][col] == 'n') || (whooseMove == 1 && board[row][col] == 'N'))
            {
                return; // King is under check by the knight
            }
        }
    }

    return;
}



//rook attack

void rookCheck(int x,int y, int whooseMove)
{
    int dik[4][2]= {{-1,0},{1,0},{0,-1},{0,1}};
    for(int i=0; i<4; ++i)
    {
        int row=x+dik[i][0];
        int col=y+dik[i][1];
        while(row>=0 && row<6 && col >=0 && col<5)
        {
            if(board[row][col] != ' ')
            {
                if((whooseMove ==0 && board[x-1][y-1]=='k') || (whooseMove==1 && board[x-1][y-1]=='K')) {
                return;
            }
            break;
        }
        row += dik[i][0];
            col +=dik[i][1] ;
        }
    }
    return ;
}

//bishop attack

void bishopCheck(int x, int y, int whooseMove)
{
    int dik[4][2] = { {-1, -1}, {-1, 1}, {1, -1}, {1, 1} };

    for (int i = 0; i < 4; ++i)
    {
        int row = x + dik[i][0];
        int col = y + dik[i][1];

        while (row >= 0 && row < 6 && col >= 0 && col < 5)
        {
            if (board[row][col] != ' ')
            {
                if ((whooseMove == 0 && board[x-1][y-1] == 'k') || (whooseMove == 1 && board[x-1][y-1] == 'K'))
                {
                    return; // King is under check by the bishop
                }
                break;
            }

            row += dik[i][0];
            col += dik[i][1];
        }
    }

    return;
}


// queen attack

void queenCheck(int x, int y, int whooseMove)
{
    int dik[8][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1} };

    for (int i = 0; i < 8; ++i)
    {
        int row = x + dik[i][0];
        int col = y + dik[i][1];

        while (row >= 0 && row < 6 && col >= 0 && col < 5)
        {
            if (board[row][col] != ' ')
            {
                if ((whooseMove == 0 && board[x-1][y-1] == 'k') || (whooseMove == 1 && board[x-1][y-1] == 'K'))
                {
                    return; // King is under check by the queen
                }
                break;
            }

            row += dik[i][0];
            col += dik[i][1];
        }
    }

    return;
}

//king attack
void kingCheck(int x, int y, int whooseMove)
{
    int dik[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};

    for (int i = 0; i < 8; ++i)
    {
        int row = x + dik[i][0];
        int col = y + dik[i][1];

        if (row >= 0 && row < 6 && col >= 0 && col < 5 && (board[row][col] == 'K' || board[row][col] == 'k'))
        {
            if (whooseMove == 0 && board[row][col] == 'K')
            {
                return ; // White king is under check

            }
            else if (whooseMove == 1 && board[row][col] == 'k')
            {
                return; // Black king is under check
            }
        }
    }

    return; // King is not under check
}




void check(int x,int y,int whooseMove)
{
    if(whooseMove==1)
    {
        if(board[x][y]='P')
        {
            pawnCheck(x,y,0);
        }
        if(board[x][y]='K')
        {
            kingCheck(x,y,0);
        }
        if(board[x][y]='N')
        {
            knightCheck(x,y,0);
        }
        if(board[x][y]='R')
        {
            rookCheck(x,y,0);
        }
        if(board[x][y]='B')
        {
            bishopCheck(x,y,0);
        }
        if(board[x][y]='Q')
        {
            queenCheck(x,y,0);
        }
    }
    if(whooseMove==0)
    {
        if(board[x][y]='p')
        {
            pawnCheck(x,y,0);
        }
        if(board[x][y]='k')
        {
            kingCheck(x,y,0);
        }
        if(board[x][y]='n')
        {
            knightCheck(x,y,0);
        }
        if(board[x][y]='r')
        {
            rookCheck(x,y,0);
        }
        if(board[x][y]='b')
        {
            bishopCheck(x,y,0);
        }
        if(board[x][y]='q')
        {
            queenCheck(x,y,0);
        }
    }

}



void selectandmove()
{
    delay(1);
    setcolor(RED);


    for (int i = 0; i < 5; ++i)
    {
        rectangle(selectedx*100 - i, selectedy*100 - i, selectedx*100+100 + i, selectedy*100+100 + i);
    }


    // printf(" selectedx=%d ,selectedy=%d",selectedx,selectedy);
    delay(60);
}


/*
int minimax(int position,int depth, int whooseMove){

        if(depth==0){
            return -1;
        }

        if(whooseMove==0){
            maxVal= -100000;

        }

}
*/

int moving = 0;

int selectSquare(int x, int y)
{


    int x1 = x*100, y1 = y*100, x2 = x*100+100, y2 = y*100+100;


    while(1)
    {
        //cleardevice();
        if(moving==1)
        {
            selectandmove();
            delay(60);
        }

        setcolor(LIGHTGREEN);
        //rectangle(100,100,200,200);
        for (int i = 0; i < 5; ++i)
        {

            rectangle(x*100 - i, y*100 - i, x*100+100 + i, y*100+100 + i);

        }


        if(GetAsyncKeyState(VK_RIGHT))
        {
            //x1 += 100;
            //x2 += 100;
            x += 1;
            cleardevice();
            DrawChessboard();
            if(moving==1)
            {
                selectandmove();
                delay(60);
            }
        }

        if(GetAsyncKeyState(VK_LEFT))
        {
            //x1 -= 100;
            //x2 -= 100;
            x-=1;
            cleardevice();
            DrawChessboard();
            if(moving==1)
            {
                selectandmove();
                delay(60);
            }
        }



        if(GetAsyncKeyState(VK_UP))
        {
            //y1 -= 100;
            //y2 -= 100;
            y-=1;
            cleardevice();
            DrawChessboard();
            if(moving==1)
            {
                selectandmove();
                delay(60);
            }
        }

        if(GetAsyncKeyState(VK_DOWN))
        {
            //y1 += 100;
            //y2 += 100;
            y+=1;
            cleardevice();
            DrawChessboard();
            if(moving==1)
            {
                selectandmove();
                delay(1);
            }
        }

        if(GetAsyncKeyState(VK_RETURN))
        {
            if(moving==0)
            {
                selectedx = x;
                selectedy = y;
                selectandmove();
                moving = 1;
            }

            else
            {
                if(board[selectedy-1][selectedx-1] >= 65 && board[selectedy-1][selectedx-1] <= 90)
                {
                    if(whooseMove == 0)
                    {
                        printf("WHITEMOVED,%c",board[selectedy-1][selectedx-1]);



                        pawnmove(x,y);
                        rookmove(x,y);
                        bishopmove(x,y);
                        knightmove(x,y);
                        queenmove(x,y);
                        kingmove(x,y);
                        whooseMove = 1;
                        moving=0;
                        selectedx = 0;
                        selectedy = 0;
                        DrawChessboard();
                    }
                    else
                    {
                        moving=0;
                        selectedx = 0;
                        selectedy = 0;
                        DrawChessboard();
                        if(moving==1)
                        {
                            selectandmove();
                            delay(1);
                        }
                    }
                }
                else
                {
                    if(whooseMove == 1)
                    {
                        printf("BLACKMOVED,%c",board[selectedy-1][selectedx-1]);
                        pawnmove(x,y);
                        rookmove(x,y);
                        bishopmove(x,y);
                        knightmove(x,y);
                        queenmove(x,y);
                        kingmove(x,y);
                        whooseMove = 0;
                        moving=0;
                        selectedx = 0;
                        selectedy = 0;
                        DrawChessboard();


                    }
                    else
                    {
                        moving=0;
                        selectedx = 0;
                        selectedy = 0;
                        DrawChessboard();

                    }
                }

            }

            x++;
            y++;
            delay(60);
        }
        delay(60);
    }
    return 0;

}





int main()
{


    int gr = DETECT, gm;

    initwindow(800,800,"MENU",0,0,false,true);

    DrawChessboard();

    selectSquare(1,1);


    getch();
    closegraph();


    return 0;
}

